<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Estribadeira 3D Automática</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
        }

        #canvas3d {
            width: 100%;
            height: 100%;
        }

        .overlay {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(26, 26, 26, 0.95);
            padding: 15px 30px;
            border-radius: 8px;
            border: 2px solid #00ff88;
            text-align: center;
            z-index: 100;
        }

        .overlay h2 {
            font-size: 18px;
            color: #00ff88;
            font-weight: 600;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(26, 26, 26, 0.95);
            padding: 40px 60px;
            border-radius: 10px;
            border: 2px solid #00ff88;
            text-align: center;
            z-index: 200;
        }

        .loading h3 {
            color: #00ff88;
            margin-bottom: 20px;
            font-size: 18px;
        }

        .loading-bar {
            width: 250px;
            height: 8px;
            background: #2a2a2a;
            border-radius: 4px;
            overflow: hidden;
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #3a7bc8);
            width: 0%;
            transition: width 0.3s;
        }

        .loading-text {
            margin-top: 15px;
            font-size: 13px;
            color: #888;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(26, 26, 26, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #3a3a3a;
            z-index: 100;
        }

        .controls h4 {
            color: #00ff88;
            margin-bottom: 10px;
            font-size: 12px;
        }

        .controls p {
            font-size: 11px;
            color: #888;
            margin: 4px 0;
        }

        .btn-group {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 100;
        }

        .btn {
            background: #00ff88;
            color: #1a1a1a;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #00cc6a;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #3a3a3a;
            color: #e0e0e0;
        }

        .btn-secondary:hover {
            background: #4a4a4a;
        }

        .legend-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(26, 26, 26, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #3a3a3a;
            z-index: 100;
            max-width: 280px;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .legend-panel.hidden {
            transform: translateX(320px);
            opacity: 0;
            pointer-events: none;
        }

        .legend-toggle {
            position: absolute;
            top: 20px;
            right: 310px;
            background: rgba(26, 26, 26, 0.95);
            color: #00ff88;
            border: 1px solid #3a3a3a;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            z-index: 101;
            transition: all 0.3s ease;
        }

        .legend-toggle:hover {
            background: #00ff88;
            color: #1a1a1a;
        }

        .legend-toggle.panel-hidden {
            right: 20px;
        }

        .legend-panel h4 {
            color: #00ff88;
            margin-bottom: 12px;
            font-size: 14px;
            border-bottom: 1px solid #3a3a3a;
            padding-bottom: 8px;
        }

        .legend-stats {
            font-size: 11px;
            color: #888;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #2a2a2a;
        }

        .legend-item {
            display: flex;
            align-items: center;
            padding: 4px 5px;
            font-size: 10px;
            cursor: pointer;
            transition: background 0.2s;
            border-radius: 4px;
        }

        .legend-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .legend-item.highlighted {
            background: rgba(0, 255, 136, 0.2);
        }

        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 3px;
            margin-right: 8px;
            flex-shrink: 0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .legend-name {
            color: #ccc;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .legend-panel::-webkit-scrollbar {
            width: 6px;
        }

        .legend-panel::-webkit-scrollbar-track {
            background: #2a2a2a;
            border-radius: 3px;
        }

        .legend-panel::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 3px;
        }

        .credits {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(26, 26, 26, 0.9);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 11px;
            color: #888;
            z-index: 100;
        }

        .credits a {
            color: #00ff88;
            text-decoration: none;
        }

        .credits a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="overlay">
        <h2>Estribadeira 3D Automática</h2>
    </div>

    <div class="loading" id="loadingScreen">
        <h3>Carregando Modelo 3D</h3>
        <div class="loading-bar">
            <div class="loading-progress" id="loadingProgress"></div>
        </div>
        <div class="loading-text" id="loadingText">Iniciando...</div>
    </div>

    <div class="controls">
        <h4>Controles da Camera</h4>
        <p>Arrastar: Rotacionar</p>
        <p>Scroll: Zoom</p>
        <p>Shift + Arrastar: Mover</p>
        <p>Duplo clique: Centralizar</p>
    </div>

    <button class="legend-toggle" id="legendToggle" onclick="toggleLegend()">☰ Peças</button>
    <div class="legend-panel" id="legendPanel">
        <h4>Pecas do Modelo</h4>
        <div class="legend-stats" id="legendStats">Carregando...</div>
        <div id="legendItems"></div>
    </div>

    <div class="btn-group">
        <button class="btn" onclick="toggleSimulation()" id="btnSimular">Simular</button>
        <button class="btn btn-secondary" onclick="resetCamera()">Resetar Camera</button>
        <button class="btn btn-secondary" onclick="toggleWireframe()">Wireframe</button>
        <button class="btn btn-secondary" onclick="toggleAutoRotate()">Auto Rotacao</button>
        <button class="btn btn-secondary" onclick="cycleBackground()">Mudar Fundo</button>
    </div>

    <div class="credits">
        Desenvolvido por <a href="https://www.linkedin.com/in/lucas-william-junges-a95b00143/" target="_blank">Eng. Lucas Junges</a>
    </div>

    <div id="canvas3d"></div>

    <!-- Three.js + STLLoader -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>

    <script>
        // ============================================================================
        // VARIAVEIS GLOBAIS
        // ============================================================================
        let scene, camera, renderer, controls;
        let modelGroup = null;
        let partMeshes = [];
        let partsManifest = null;
        let isWireframe = false;
        let backgroundIndex = 0;
        const backgrounds = [0x1a1a1a, 0x2a3a4a, 0x3a2a3a, 0x1a2a1a, 0x000000];

        // Paleta de cores distintas (20 cores que se repetem)
        const colorPalette = [
            0x4CAF50, 0x2196F3, 0xF44336, 0xFF9800, 0x9C27B0,
            0x00BCD4, 0xFFC107, 0xE91E63, 0x8BC34A, 0x3F51B5,
            0xFF5722, 0x009688, 0xCDDC39, 0x673AB7, 0x03A9F4,
            0x795548, 0x607D8B, 0xFFEB3B, 0x00E676, 0xD500F9
        ];

        // Nomes das pecas baseados em analise das dimensoes
        const partNames = {
            0: "Base Principal",
            1: "Eixo Guia Arame",
            2: "Suporte Lateral E",
            3: "Suporte Lateral D",
            4: "Engrenagem Alimentador 1",
            5: "Engrenagem Alimentador 2",
            6: "Mancal Esquerdo",
            7: "Mancal Direito",
            8: "Espacador E",
            9: "Espacador D",
            10: "Arruela 1",
            11: "Arruela 2",
            12: "Placa Secundaria",
            13: "Suporte Motor NEMA",
            14: "Caixa Engrenagens",
            15: "Placa Motor",
            16: "Coluna 1",
            17: "Porca 1",
            18: "Porca 2",
            19: "Rolamento 1",
            20: "Bloco Dobrador",
            21: "Parafuso 1",
            22: "Parafuso 2",
            23: "Parafuso 3",
            24: "Eixo Vertical",
            25: "Bracadeira Eixo",
            26: "Motor Principal",
            27: "Servo Motor 1",
            28: "Engrenagem Z 1",
            29: "Engrenagem Z 2",
            30: "Pino Guia",
            31: "Trilho Superior",
            32: "Trilho Inferior",
            33: "Coluna 2",
            34: "Rolamento 2",
            35: "Porca 3",
            36: "Coluna 3",
            37: "Coluna 4",
            38: "Porca 4",
            39: "Porca 5",
            40: "Rolamento 3",
            41: "Rolamento 4",
            42: "Porca 6",
            43: "Porca 7",
            44: "Coluna 5",
            45: "Coluna 6",
            46: "Porca 8",
            47: "Porca 9",
            48: "Porca 10",
            49: "Porca 11",
            50: "Rolamento 5",
            51: "Rolamento 6",
            52: "Servo Motor 2",
            53: "Placa Fixacao 1",
            54: "Placa Fixacao 2",
            55: "Placa Fixacao 3",
            56: "Placa Fixacao 4",
            57: "Placa Fixacao 5",
            58: "Espacador Longo",
            59: "Espacador Curto",
            60: "Suporte Alimentador",
            61: "Coluna 7",
            62: "Rolamento 7",
            63: "Porca 12",
            64: "Coluna 8",
            65: "Arruela Fina",
            66: "Porca 13",
            67: "Porca 14",
            68: "Guia Arame E",
            69: "Bracadeira E",
            70: "Bracadeira D",
            71: "Guia Arame D",
            72: "Bocal Dobrador",
            73: "Arruela 3",
            74: "Porca 15",
            75: "Arruela 4",
            76: "Arruela 5",
            77: "Arruela 6",
            78: "Arruela 7",
            79: "Barra Estrutural 1",
            80: "Barra Estrutural 2",
            81: "Barra Estrutural 3",
            82: "Barra Estrutural 4",
            83: "Placa Base Inferior",
            84: "Conector"
        };

        let loadedCount = 0;
        let totalParts = 0;
        let isSimulating = false;

        // Configuracao de animacao das pecas rotativas individuais
        // (giram no proprio eixo, sem orbitar)
        const animatedParts = {
            29: { axis: 'x', speed: -0.0075 },  // Engrenagem Z2 - gira no proprio eixo X (sentido oposto)
            53: { axis: 'z', speed: -0.01 },   // Placa Fixacao 1 - gira em Z (sentido oposto)
            54: { axis: 'z', speed: -0.01 },   // Placa Fixacao 2 - gira em Z (sentido oposto)
            55: { axis: 'z', speed: 0.01 },    // Placa Fixacao 3 - gira em Z
            56: { axis: 'z', speed: 0.01 },    // Placa Fixacao 4 - gira em Z
            57: { axis: 'z', speed: -0.01 },   // Placa Fixacao 5 - gira em Z (sentido oposto)
            62: { axis: 'z', speed: 0.01 },    // Rolamento 7 - gira em Z
        };

        // Grupos mecanicos - pecas que giram juntas em torno de um pivo comum
        const mechanicalGroups = {
            // Mecanismo principal - gira ao redor do eixo X
            // Engrenagem Z1 + Eixo Guia + Mancais + etc (SEM Placa Motor e Motor Principal)
            eixoPrincipal: {
                pivot: [300, -240.5, 185],  // Centro aproximado no eixo do arame
                axis: 'x',
                speed: 0.005,
                parts: [
                    28,  // Engrenagem Z 1
                    1,   // Eixo Guia Arame
                    6,   // Mancal Esquerdo
                    7,   // Mancal Direito
                    8,   // Espacador E
                    9,   // Espacador D
                    10,  // Arruela 1
                    11,  // Arruela 2
                    12,  // Placa Secundaria
                    13,  // Suporte Motor NEMA
                    14,  // Caixa Engrenagens
                    16,  // Coluna 1
                    17,  // Porca 1
                    18,  // Porca 2
                    19,  // Rolamento 1
                ],
                // Sub-grupos que giram dentro deste grupo
                subGroups: {
                    // Placa Motor - gira sincronizada com mecanismoDobrador
                    placaMotorGira: {
                        pivot: [432.2, -240.46, 159.8],  // Centro da Placa Motor
                        axis: 'z',  // Gira em Z (perpendicular a placa)
                        speed: 0.01,
                        syncWithDobrador: true,  // Sincroniza com mecanismoDobrador
                        parts: [
                            15,  // Placa Motor
                        ]
                    },
                    // Mecanismo do dobrador - oscila ao redor da Coluna 1
                    mecanismoDobrador: {
                        pivot: [492.2, -240.43, 156.35],  // Centro da Coluna 1
                        axis: 'z',  // Oscila em Z ao redor da Coluna 1
                        speed: 0.01,
                        oscillate: true,  // Oscila em vez de girar continuamente
                        minAngle: 175 * Math.PI / 180,  // Limite minimo (175 graus)
                        maxAngle: 375 * Math.PI / 180,  // Limite maximo (375 graus)
                        direction: -1,  // Direcao inicial
                        parts: [
                            20,  // Bloco Dobrador
                            21,  // Parafuso 1
                            22,  // Parafuso 2
                            23,  // Parafuso 3
                            24,  // Eixo Vertical
                            26,  // Motor Principal
                            30,  // Pino Guia (fica no mesmo plano, so desliza)
                        ],
                        subGroups: {
                            // Bracadeira Eixo - oscila e controla o Pino Guia
                            bracadeiraEixo: {
                                pivot: [504.92, -215.6, 121.08],  // Centro real da Bracadeira Eixo
                                axis: 'y',  // Oscila em Y
                                speed: 0.0075,
                                oscillate: true,
                                minAngle: 0,  // 0 graus
                                maxAngle: Math.PI,  // 180 graus
                                direction: 1,
                                controlsPinoGuia: true,  // Flag especial para controlar o Pino Guia
                                parts: [
                                    25,  // Bracadeira Eixo
                                ]
                            }
                        }
                    }
                }
            }
            // Bocal Dobrador (72) e Engrenagem Z2 (29) ficam parados/giram no lugar
        };

        // Grupos Three.js para mecanismos
        const mechGroups = {};

        // ============================================================================
        // INICIALIZACAO
        // ============================================================================
        function init() {
            const container = document.getElementById('canvas3d');

            // Cena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(backgrounds[0]);

            // Camera
            camera = new THREE.PerspectiveCamera(
                45,
                window.innerWidth / window.innerHeight,
                0.1,
                10000
            );
            camera.position.set(300, 200, 400);

            // Renderer
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            container.appendChild(renderer.domElement);

            // Controles
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = true;
            controls.minDistance = 50;
            controls.maxDistance = 2000;
            controls.target.set(0, 50, 0);

            // Luzes
            setupLights();

            // Grid
            const grid = new THREE.GridHelper(500, 25, 0x444444, 0x333333);
            grid.position.y = -10;
            scene.add(grid);

            // Eixos globais (vermelho=X, verde=Y, azul=Z)
            const axesHelper = new THREE.AxesHelper(200);
            scene.add(axesHelper);

            // Labels dos eixos
            addAxisLabel('X', 210, 0, 0, 0xff0000);
            addAxisLabel('Y', 0, 210, 0, 0x00ff00);
            addAxisLabel('Z', 0, 0, 210, 0x0000ff);

            // Grupo para o modelo
            modelGroup = new THREE.Group();
            scene.add(modelGroup);

            // Carregar manifest e depois as pecas
            loadManifest();

            // Eventos
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('dblclick', onDoubleClick);

            // Loop
            animate();
        }

        function addAxisLabel(text, x, y, z, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 32, 32);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.position.set(x, y, z);
            sprite.scale.set(30, 30, 1);
            scene.add(sprite);
        }

        function setupLights() {
            // Ambiente
            const ambient = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambient);

            // Hemisphere (ceu/chao)
            const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            hemi.position.set(0, 200, 0);
            scene.add(hemi);

            // Principal
            const main = new THREE.DirectionalLight(0xffffff, 0.8);
            main.position.set(150, 300, 200);
            main.castShadow = true;
            main.shadow.mapSize.width = 2048;
            main.shadow.mapSize.height = 2048;
            main.shadow.camera.near = 10;
            main.shadow.camera.far = 1000;
            main.shadow.camera.left = -200;
            main.shadow.camera.right = 200;
            main.shadow.camera.top = 200;
            main.shadow.camera.bottom = -200;
            scene.add(main);

            // Preenchimento
            const fill = new THREE.DirectionalLight(0x88aaff, 0.3);
            fill.position.set(-100, 100, -100);
            scene.add(fill);

            // Rim
            const rim = new THREE.DirectionalLight(0xffffff, 0.2);
            rim.position.set(0, 50, -200);
            scene.add(rim);
        }

        // ============================================================================
        // CARREGAMENTO DO MANIFEST
        // ============================================================================
        function loadManifest() {
            updateLoading(5, 'Carregando manifest...');

            fetch('models/parts_manifest.json')
                .then(response => response.json())
                .then(data => {
                    partsManifest = data;
                    totalParts = data.parts.length;
                    console.log(`Manifest carregado: ${totalParts} pecas`);
                    createLegend();
                    loadAllParts();
                })
                .catch(error => {
                    console.error('Erro ao carregar manifest:', error);
                    document.getElementById('loadingText').textContent = 'Erro ao carregar manifest!';
                });
        }

        // ============================================================================
        // CRIACAO DA LEGENDA
        // ============================================================================
        function createLegend() {
            const legendItems = document.getElementById('legendItems');
            legendItems.innerHTML = '';

            partsManifest.parts.forEach((part, index) => {
                const color = colorPalette[index % colorPalette.length];

                const item = document.createElement('div');
                item.className = 'legend-item';
                item.dataset.index = index;

                const colorBox = document.createElement('div');
                colorBox.className = 'legend-color';
                colorBox.style.backgroundColor = '#' + color.toString(16).padStart(6, '0');

                const nameSpan = document.createElement('span');
                nameSpan.className = 'legend-name';
                // Usar nome descritivo do mapeamento
                let displayName = partNames[index] || `Peca ${index}`;
                nameSpan.textContent = displayName;
                nameSpan.title = `${displayName} (${part.faces} faces)`;

                item.appendChild(colorBox);
                item.appendChild(nameSpan);

                // Interatividade
                item.addEventListener('mouseenter', () => highlightPart(index, true));
                item.addEventListener('mouseleave', () => highlightPart(index, false));
                item.addEventListener('click', () => focusOnPart(index));

                legendItems.appendChild(item);
            });
        }

        function highlightPart(index, highlight) {
            const mesh = partMeshes[index];
            if (mesh) {
                if (highlight) {
                    mesh.userData.originalEmissive = mesh.material.emissive.getHex();
                    mesh.material.emissive.setHex(0x444444);
                } else {
                    mesh.material.emissive.setHex(mesh.userData.originalEmissive || 0x000000);
                }
            }

            const legendItem = document.querySelector(`.legend-item[data-index="${index}"]`);
            if (legendItem) {
                legendItem.classList.toggle('highlighted', highlight);
            }
        }

        function focusOnPart(index) {
            const mesh = partMeshes[index];
            if (mesh) {
                const box = new THREE.Box3().setFromObject(mesh);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);

                controls.target.copy(center);
                const distance = Math.max(maxDim * 3, 50);
                const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
                camera.position.copy(center).add(direction.multiplyScalar(distance));
            }
        }

        // ============================================================================
        // CARREGAMENTO DAS PECAS
        // ============================================================================
        function loadAllParts() {
            const loader = new THREE.STLLoader();

            updateLoading(10, 'Carregando pecas...');

            partsManifest.parts.forEach((part, index) => {
                const filePath = 'models/parts/' + part.file;
                const color = colorPalette[index % colorPalette.length];

                loader.load(
                    filePath,
                    (geometry) => {
                        // Material com cor especifica
                        const material = new THREE.MeshStandardMaterial({
                            color: color,
                            metalness: 0.4,
                            roughness: 0.5,
                            flatShading: false
                        });

                        // Verificar se a peca pertence a um grupo mecanico
                        let isInMechGroup = false;
                        for (const config of Object.values(mechanicalGroups)) {
                            if (config.parts.includes(index)) {
                                isInMechGroup = true;
                                break;
                            }
                        }

                        // Para pecas animadas individualmente, centralizar a geometria
                        let mesh;
                        if (animatedParts[index] && !isInMechGroup) {
                            // Calcular centro da geometria
                            geometry.computeBoundingBox();
                            const center = new THREE.Vector3();
                            geometry.boundingBox.getCenter(center);

                            // Centralizar a geometria (mover vertices para origem)
                            geometry.translate(-center.x, -center.y, -center.z);

                            // Criar mesh e posicionar no centro original
                            mesh = new THREE.Mesh(geometry, material);
                            mesh.position.copy(center);
                        } else {
                            // Pecas estaticas ou de grupos mecanicos - manter posicao original
                            mesh = new THREE.Mesh(geometry, material);
                        }

                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        mesh.userData.partName = partNames[index] || `Peca ${index}`;
                        mesh.userData.partIndex = index;

                        partMeshes[index] = mesh;
                        modelGroup.add(mesh);

                        loadedCount++;
                        const percent = 10 + (loadedCount / totalParts) * 85;
                        updateLoading(percent, `Carregando: ${loadedCount}/${totalParts}`);

                        if (loadedCount === totalParts) {
                            onAllPartsLoaded();
                        }
                    },
                    undefined,
                    (error) => {
                        console.error(`Erro ao carregar ${part.file}:`, error);
                        loadedCount++;
                        if (loadedCount === totalParts) {
                            onAllPartsLoaded();
                        }
                    }
                );
            });
        }

        function onAllPartsLoaded() {
            console.log('Todas as pecas carregadas!');

            // Criar grupos mecanicos
            setupMechanicalGroups();

            // Centralizar o grupo
            const box = new THREE.Box3().setFromObject(modelGroup);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());

            // Mover grupo para o centro
            modelGroup.position.sub(center);
            modelGroup.position.y += size.y / 2;

            // Ajustar camera
            const maxDim = Math.max(size.x, size.y, size.z);
            camera.position.set(maxDim * 1.2, maxDim * 0.8, maxDim * 1.2);
            controls.target.set(0, size.y / 3, 0);
            controls.minDistance = maxDim * 0.3;
            controls.maxDistance = maxDim * 4;

            // Atualizar estatisticas
            let totalVertices = 0;
            let totalFaces = 0;
            partMeshes.forEach(mesh => {
                if (mesh && mesh.geometry) {
                    totalVertices += mesh.geometry.attributes.position.count;
                    totalFaces += mesh.geometry.attributes.position.count / 3;
                }
            });

            document.getElementById('legendStats').innerHTML =
                `<strong>${partMeshes.filter(m => m).length}</strong> pecas carregadas<br>` +
                `<strong>${totalVertices.toLocaleString()}</strong> vertices<br>` +
                `<strong>${Math.round(totalFaces).toLocaleString()}</strong> triangulos`;

            finishLoading();
        }

        function updateLoading(percent, text) {
            document.getElementById('loadingProgress').style.width = percent + '%';
            document.getElementById('loadingText').textContent = text;
        }

        function finishLoading() {
            document.getElementById('loadingScreen').style.display = 'none';
            console.log('Modelo carregado com sucesso!');
        }

        // ============================================================================
        // FUNCOES DE CONTROLE
        // ============================================================================
        function resetCamera() {
            if (modelGroup) {
                const box = new THREE.Box3().setFromObject(modelGroup);
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);

                camera.position.set(maxDim * 1.2, maxDim * 0.8, maxDim * 1.2);
                controls.target.set(0, size.y / 3, 0);
            }
        }

        function toggleWireframe() {
            isWireframe = !isWireframe;
            partMeshes.forEach(mesh => {
                if (mesh && mesh.material) {
                    mesh.material.wireframe = isWireframe;
                }
            });
        }

        function toggleAutoRotate() {
            controls.autoRotate = !controls.autoRotate;
            controls.autoRotateSpeed = 2.0;
        }

        function cycleBackground() {
            backgroundIndex = (backgroundIndex + 1) % backgrounds.length;
            scene.background = new THREE.Color(backgrounds[backgroundIndex]);
        }

        function toggleLegend() {
            const panel = document.getElementById('legendPanel');
            const toggle = document.getElementById('legendToggle');
            panel.classList.toggle('hidden');
            toggle.classList.toggle('panel-hidden');
            if (panel.classList.contains('hidden')) {
                toggle.textContent = '☰ Peças';
            } else {
                toggle.textContent = '✕ Fechar';
            }
        }

        function toggleSimulation() {
            isSimulating = !isSimulating;
            const btn = document.getElementById('btnSimular');
            if (isSimulating) {
                btn.textContent = 'Parar';
                btn.style.background = '#F44336';
            } else {
                btn.textContent = 'Simular';
                btn.style.background = '#00ff88';
            }
        }

        function setupMechanicalGroups() {
            // Funcao recursiva para criar sub-grupos
            function createSubGroups(parentGroup, parentPivot, subGroupsConfig, parentName) {
                if (!subGroupsConfig) return;

                for (const [subName, subConfig] of Object.entries(subGroupsConfig)) {
                    const subGroup = new THREE.Group();
                    const subPivot = new THREE.Vector3(...subConfig.pivot);

                    // Posicionar sub-grupo relativo ao grupo pai
                    subGroup.position.copy(subPivot).sub(parentPivot);

                    // Mover pecas do sub-grupo
                    subConfig.parts.forEach(partIndex => {
                        const mesh = partMeshes[partIndex];
                        if (mesh) {
                            // Remover do modelGroup (se ainda estiver la)
                            modelGroup.remove(mesh);

                            // Ajustar posicao relativa ao pivo do sub-grupo
                            mesh.position.sub(subPivot);

                            // Adicionar ao sub-grupo
                            subGroup.add(mesh);
                        }
                    });

                    // Recursivamente criar sub-sub-grupos
                    if (subConfig.subGroups) {
                        createSubGroups(subGroup, subPivot, subConfig.subGroups, `${parentName}_${subName}`);
                    }

                    // Adicionar sub-grupo ao grupo pai
                    parentGroup.add(subGroup);
                    const fullName = `${parentName}_${subName}`;
                    mechGroups[fullName] = subGroup;

                    console.log(`  Sub-grupo '${fullName}' criado com ${subConfig.parts.length} pecas`);
                }
            }

            // Para cada grupo mecanico principal, criar um Group do Three.js
            for (const [name, config] of Object.entries(mechanicalGroups)) {
                const group = new THREE.Group();
                const pivot = new THREE.Vector3(...config.pivot);

                // Posicionar o grupo no ponto de pivo
                group.position.copy(pivot);

                // Mover cada peca do grupo
                config.parts.forEach(partIndex => {
                    const mesh = partMeshes[partIndex];
                    if (mesh) {
                        // Remover do modelGroup
                        modelGroup.remove(mesh);

                        // Ajustar posicao relativa ao pivo
                        mesh.position.sub(pivot);

                        // Adicionar ao grupo mecanico
                        group.add(mesh);
                    }
                });

                // Criar sub-grupos recursivamente
                createSubGroups(group, pivot, config.subGroups, name);

                // Adicionar grupo ao modelGroup
                modelGroup.add(group);
                mechGroups[name] = group;

                console.log(`Grupo mecanico '${name}' criado com ${config.parts.length} pecas`);
            }
        }

        function animateParts() {
            if (!isSimulating) return;

            // Animar pecas individuais (rotacao continua)
            for (const [index, config] of Object.entries(animatedParts)) {
                const mesh = partMeshes[parseInt(index)];
                if (mesh) {
                    switch (config.axis) {
                        case 'x':
                            mesh.rotation.x += config.speed;
                            break;
                        case 'y':
                            mesh.rotation.y += config.speed;
                            break;
                        case 'z':
                            mesh.rotation.z += config.speed;
                            break;
                    }
                }
            }

            // Funcao recursiva para animar sub-grupos
            function animateSubGroups(subGroupsConfig, parentName) {
                if (!subGroupsConfig) return;

                for (const [subName, subConfig] of Object.entries(subGroupsConfig)) {
                    const fullName = `${parentName}_${subName}`;
                    const subGroup = mechGroups[fullName];
                    if (subGroup) {
                        let rotationAxis;
                        switch (subConfig.axis) {
                            case 'x': rotationAxis = 'x'; break;
                            case 'y': rotationAxis = 'y'; break;
                            case 'z': rotationAxis = 'z'; break;
                        }

                        // Sincronizar com mecanismoDobrador (sentido oposto)
                        if (subConfig.syncWithDobrador) {
                            const dobradorConfig = mechanicalGroups.eixoPrincipal.subGroups.mecanismoDobrador;
                            subGroup.rotation[rotationAxis] += subConfig.speed * (-dobradorConfig.direction);
                        }
                        else if (subConfig.oscillate) {
                            // Movimento oscilatorio com limites
                            const currentAngle = subGroup.rotation[rotationAxis];
                            const newAngle = currentAngle + subConfig.speed * subConfig.direction;

                            // Verificar limites e inverter direcao se necessario
                            if (newAngle >= subConfig.maxAngle) {
                                subGroup.rotation[rotationAxis] = subConfig.maxAngle;
                                subConfig.direction = -1;
                            } else if (newAngle <= subConfig.minAngle) {
                                subGroup.rotation[rotationAxis] = subConfig.minAngle;
                                subConfig.direction = 1;
                            } else {
                                subGroup.rotation[rotationAxis] = newAngle;
                            }

                            // Controlar posicao do Pino Guia e Eixo Vertical baseado no angulo da Bracadeira
                            if (subConfig.controlsPinoGuia) {
                                // Normalizar angulo entre 0 e 1
                                const angleRange = subConfig.maxAngle - subConfig.minAngle;
                                const normalizedAngle = (subGroup.rotation[rotationAxis] - subConfig.minAngle) / angleRange;
                                const deslocamento = 50 * normalizedAngle;

                                // Pino Guia
                                const pinoGuia = partMeshes[30];
                                if (pinoGuia) {
                                    if (pinoGuia.userData.initialZ === undefined) {
                                        pinoGuia.userData.initialZ = pinoGuia.position.z;
                                    }
                                    pinoGuia.position.z = pinoGuia.userData.initialZ - deslocamento;
                                }

                                // Eixo Vertical
                                const eixoVertical = partMeshes[24];
                                if (eixoVertical) {
                                    if (eixoVertical.userData.initialZ === undefined) {
                                        eixoVertical.userData.initialZ = eixoVertical.position.z;
                                    }
                                    eixoVertical.position.z = eixoVertical.userData.initialZ - deslocamento;
                                }
                            }
                        } else {
                            // Rotacao continua
                            subGroup.rotation[rotationAxis] += subConfig.speed;
                        }
                    }

                    // Recursivamente animar sub-sub-grupos
                    if (subConfig.subGroups) {
                        animateSubGroups(subConfig.subGroups, fullName);
                    }
                }
            }

            // Animar grupos mecanicos principais
            for (const [name, config] of Object.entries(mechanicalGroups)) {
                const group = mechGroups[name];
                if (group) {
                    switch (config.axis) {
                        case 'x':
                            group.rotation.x += config.speed;
                            break;
                        case 'y':
                            group.rotation.y += config.speed;
                            break;
                        case 'z':
                            group.rotation.z += config.speed;
                            break;
                    }
                }

                // Animar sub-grupos recursivamente
                animateSubGroups(config.subGroups, name);
            }
        }

        function onDoubleClick(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(partMeshes.filter(m => m), true);
            if (intersects.length > 0) {
                controls.target.copy(intersects[0].point);
                const clickedMesh = intersects[0].object;
                if (clickedMesh.userData.partName) {
                    console.log('Peca clicada:', clickedMesh.userData.partName);
                }
            }
        }

        // ============================================================================
        // LOOP E EVENTOS
        // ============================================================================
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            animateParts();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Ocultar painel em dispositivos moveis
        function checkMobile() {
            if (window.innerWidth <= 768) {
                const panel = document.getElementById('legendPanel');
                const toggle = document.getElementById('legendToggle');
                panel.classList.add('hidden');
                toggle.classList.add('panel-hidden');
                toggle.textContent = '☰ Peças';
            }
        }

        // Iniciar
        checkMobile();
        init();
    </script>
</body>
</html>
